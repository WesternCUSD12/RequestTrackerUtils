# Data Model: Streamlined Asset Creation with Batch Entry

**Feature**: 001-i-need-to  
**Date**: 2025-10-08  
**Status**: Complete

## Overview

Data model for batch asset creation with form persistence. This feature primarily leverages existing data structures in RT and the file-based asset tag sequence, adding client-side session storage for form state.

## Entities

### Asset (RT-managed, existing)

Represents physical devices tracked in Request Tracker. This is the core entity created by this feature.

**Storage**: Request Tracker database (external system)

**Key Attributes**:

- `id`: Integer (auto-generated by RT)
- `Name`: String (set to asset tag, e.g., "W12-1001")
- `CF.{Serial Number}`: String (unique organization-wide, user-entered)
- `CF.{Manufacturer}`: String (persisted across entries)
- `CF.{Model}`: String (persisted across entries)
- `CF.{Category}`: String (persisted across entries)
- `CF.{Funding Source}`: String (persisted across entries)
- `Creator`: User ID (authenticated user)
- `Created`: Timestamp (RT auto-generated)

**Validation Rules**:

- Serial Number MUST be unique across all assets in RT
- Name MUST match assigned asset tag
- All custom fields follow RT's configured field types and validation

**State Transitions**: N/A (assets are created, not transitioned)

**Relationships**:

- Created by User (RT user entity)
- May be linked to Tickets (existing RT functionality)

---

### Asset Tag Sequence (File-based, existing)

Tracks the current position in sequential asset tag numbering.

**Storage**: File (`asset_tag_sequence.txt` in working directory)

**Structure**:

```
<integer>
```

Example: `1234`

**Operations**:

- `get_current_sequence()`: Read current number
- `increment_sequence()`: Atomically increment by 1
- `get_next_tag()`: Format current number with prefix and dynamic zero-padding

**Concurrency**: File locking ensures atomic increments (handled by existing AssetTagManager)

**Validation Rules**:

- MUST be non-negative integer
- Increments MUST be sequential with no gaps
- Dynamic zero-padding: minimum 4 digits, expands as needed (0001→9999→10000)

**Relationships**:

- One sequence per organization (singleton pattern)
- Referenced by Asset Tag Audit Log entries

---

### Asset Tag Audit Log (File-based, existing)

Immutable log of asset tag assignments.

**Storage**: Append-only file (`asset_tag_confirmations.log` in working directory)

**Entry Format**:

```
<ISO timestamp> - Asset Tag: <tag>, Request Tracker ID: <RT ID>
```

Example: `2025-10-08T14:23:45 - Asset Tag: W12-1234, Request Tracker ID: 45678`

**Attributes per Entry**:

- Timestamp: ISO 8601 format
- Asset Tag: String (e.g., "W12-1234")
- RT ID: Integer (asset ID in RT)

**Operations**:

- `log_confirmation(tag, rt_id)`: Append new entry
- `get_log_entries(limit)`: Read recent entries

**Validation Rules**:

- Entries MUST be immutable once written
- Timestamp MUST be in ISO 8601 format
- Asset Tag MUST follow prefix-number pattern

---

### Batch Entry Form State (Browser session storage, NEW)

Client-side storage for persisting form values across asset creation operations within a browser tab session.

**Storage**: Browser `sessionStorage` (per-origin, per-tab)

**Structure** (JSON):

```json
{
  "manufacturer": "Dell",
  "model": "Chromebook 3100",
  "category": "Laptop",
  "funding_source": "Title I",
  "custom_field_1": "value",
  "last_updated": "2025-10-08T14:25:30Z"
}
```

**Persisted Fields**:

- manufacturer: String
- model: String
- category: String
- funding_source: String
- Any additional custom fields marked as "common"

**NOT Persisted** (cleared after success):

- serial_number: String
- internal_name: String

**Lifecycle**:

1. **Create**: After first successful asset creation
2. **Update**: After each successful asset creation (updates persisted fields)
3. **Read**: On page load to restore form state
4. **Delete**: User clicks "Clear All" OR browser tab closes

**Validation Rules**:

- Size limit: ~5KB (well within sessionStorage 5-10MB limit)
- Must be valid JSON
- No sensitive data stored (no passwords, tokens, etc.)

**Operations**:

```javascript
// Save state
sessionStorage.setItem('assetBatchForm', JSON.stringify(formState))

// Restore state
const state = JSON.parse(sessionStorage.getItem('assetBatchForm') || '{}')

// Clear state
sessionStorage.removeItem('assetBatchForm')
```

---

### Asset Label (Generated, ephemeral)

Print-ready representation of an asset for physical labeling.

**Storage**: Generated on-demand (not persisted), rendered as HTML/PDF

**Attributes**:

- asset_tag: String (e.g., "W12-1234")
- serial_number: String
- model: String
- manufacturer: String
- qr_code_data: String (URL to RT asset page)
- barcode_data: String (asset tag)
- generated_at: Timestamp

**Generation Process**:

1. Fetch asset details from RT
2. Generate QR code image (links to RT asset page)
3. Generate barcode image (asset tag)
4. Render HTML template with embedded images
5. Trigger browser print dialog

**Validation Rules**:

- QR code MUST encode valid RT asset URL
- Barcode MUST encode asset tag
- All text MUST be readable at print resolution

**Relationships**:

- Generated from Asset (1:1 ephemeral relationship)

---

## Data Flow

### Create New Asset Flow

```
1. User enters form data
   ↓
2. Client JavaScript validates required fields
   ↓
3. POST to /assets/create
   ↓
4. Server validates serial number uniqueness (query RT)
   ↓
5. Server gets next asset tag (AssetTagManager)
   ↓
6. Server creates asset in RT with tag as Name
   ↓
7. Server increments asset tag sequence
   ↓
8. Server logs tag assignment
   ↓
9. Server returns success response {asset_id, asset_tag}
   ↓
10. Client saves persisted fields to sessionStorage
   ↓
11. Client clears unique fields (serial, internal name)
   ↓
12. Client generates label (fetch /labels/print?asset_id=X)
   ↓
13. Client triggers print dialog with label HTML
   ↓
14. Client displays success message with asset tag
```

### Label Generation Failure Flow

```
1-9. [Same as above through tag assignment]
   ↓
10. Client saves persisted fields to sessionStorage
   ↓
11. Client clears unique fields
   ↓
12. Client attempts label generation → FAILS
   ↓
13. Client displays partial success message:
    - "Asset W12-1234 created successfully"
    - "Label printing failed"
    - [Retry Print] button
   ↓
14. User clicks "Retry Print"
   ↓
15. Client re-fetches label with asset_id
   ↓
16. Client triggers print dialog
```

### Clear All Flow

```
1. User clicks "Clear All" button
   ↓
2. Client clears sessionStorage ('assetBatchForm')
   ↓
3. Client resets all form fields to empty
   ↓
4. Client displays confirmation "Form cleared"
```

---

## Data Validation

### Client-Side (Pre-submission)

**Required Fields**:

- Serial Number: Non-empty, pattern validation (alphanumeric, hyphens allowed)
- Manufacturer: Non-empty
- Model: Non-empty

**Format Validation**:

- Serial Number: Max 50 characters, alphanumeric + hyphens
- Asset Tag Preview: Display formatted tag before submission

### Server-Side (Pre-RT creation)

**Uniqueness Validation**:

```python
def validate_serial_uniqueness(serial_number, rt_config):
    """
    Query RT to ensure serial number is unique organization-wide.
    Returns: (is_valid, error_message)
    """
    query = [{'field': 'CF.{Serial Number}',
              'operator': '=',
              'value': serial_number}]
    existing_assets = search_assets(query, rt_config)

    if len(existing_assets) > 0:
        asset_id = existing_assets[0].get('id')
        return (False, f"Serial number already exists (Asset #{asset_id})")

    return (True, None)
```

**Asset Tag Validation**:

```python
def validate_tag_sequence(asset_tag_manager):
    """
    Ensure asset tag sequence is valid and can be incremented.
    """
    try:
        next_tag = asset_tag_manager.get_next_tag()
        # Verify format: prefix + digits
        if not re.match(r'^W12-\d+$', next_tag):
            return (False, "Invalid tag format")
        return (True, None)
    except Exception as e:
        return (False, f"Tag sequence error: {str(e)}")
```

---

## Error Handling

### Serial Number Duplication

**Detection**: RT API query before asset creation  
**Response**: HTTP 400 with error message  
**User Experience**: Error message displayed, form data preserved, serial number field focused  
**Data State**: No changes (asset not created, sequence not incremented)

### Asset Tag Sequence File Unavailable

**Detection**: IOError on file read/write  
**Response**: HTTP 500 with error message  
**User Experience**: Error message with "try again" suggestion  
**Data State**: No changes (asset not created in RT, sequence file locked from corruption)

### RT API Failure

**Detection**: RequestException from requests library  
**Response**: HTTP 500 with error message  
**User Experience**: Error message displayed, form data preserved for retry  
**Data State**: Asset not created, sequence not incremented, no log entry

### Label Generation Failure

**Detection**: Exception during label HTML generation or print trigger  
**Response**: HTTP 200 with partial success flag  
**User Experience**: Success message + "Label failed" + "Retry Print" button  
**Data State**: Asset created in RT, sequence incremented, log entry written, form state updated

---

## Performance Characteristics

### Storage

**Asset Tag Sequence File**: ~10 bytes (grows by ~1 byte per order of magnitude)  
**Audit Log**: ~100 bytes per entry, grows unbounded (consider rotation after 10,000 entries)  
**Session Storage**: ~500 bytes per form state (negligible, cleared on tab close)

### Query Performance

**Serial Number Uniqueness Check**: O(1) index lookup in RT (200-500ms)  
**Asset Tag Sequence Read**: O(1) file read (<10ms)  
**Asset Tag Sequence Increment**: O(1) file write with lock (<10ms)

### Scalability Limits

**Asset Tag Sequence**: Supports unlimited digits (4→5→6... as needed)  
**Concurrent Users**: File locking prevents collisions (max ~10-20 concurrent creates before lock contention)  
**Audit Log**: Grows unbounded (implement rotation at 10,000 entries if needed)

---

## Migration Considerations

**No database migration required** - this feature uses existing data structures:

- RT assets already have custom fields for serial number, manufacturer, model, etc.
- Asset tag sequence file already exists
- Audit log file already exists
- No schema changes needed

**Session Storage**: Automatically available in all modern browsers, no setup required.

---

## Testing Data Requirements

### Test Assets

Create test assets with various characteristics:

- Standard 4-digit tags (W12-0001 to W12-9999)
- Boundary case at 9999→10000 transition (5-digit expansion)
- Duplicate serial numbers (validation testing)
- Missing required fields (validation testing)

### Test Scenarios

1. **Happy Path**: Create 5 assets sequentially with persisted fields
2. **Serial Duplication**: Attempt to create asset with existing serial number
3. **Label Failure**: Simulate label generation failure, verify retry works
4. **Form Persistence**: Create asset, refresh page, verify fields restored
5. **Clear All**: Persist fields, click "Clear All", verify sessionStorage cleared
6. **Digit Expansion**: Create asset at sequence 9999, verify next is W12-10000

---

## Summary

This data model leverages existing infrastructure (RT assets, file-based sequence, audit logs) and adds minimal client-side state management (sessionStorage) for form persistence. No database schema changes required. All validation occurs before data is written to permanent storage, ensuring data integrity.
